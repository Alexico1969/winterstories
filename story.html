<!doctype html>
<html lang="en">

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Story Viewer</title>
  <style>
    body {
      font-family: Segoe UI, Arial, Helvetica, sans-serif;
      padding: 20px
    }

    #controls {
      margin-bottom: 12px
    }

    button {
      margin-right: 6px;
      padding: 6px 10px
    }

    select,
    input {
      margin-right: 6px
    }

    pre {
      white-space: pre-wrap;
      border: 1px solid #ddd;
      padding: 12px;
      background: #fff
    }
  </style>
</head>

<body>
  <a href="index.html">‚Üê Back</a>
  <h1 id="title">Story</h1>

  <div id="controls">
    <div style="margin-bottom: 10px;">
      <button id="fontUp" title="Increase Font Size">A+</button>
      <button id="fontDown" title="Decrease Font Size">A-</button>
    </div>

    <!-- OpenAI controls -->
    <div style="margin-top: 10px; border-top: 1px solid #ccc; padding-top: 10px;">
      <strong>OpenAI TTS</strong>
      <input id="openaiKey" type="password" placeholder="OpenAI API Key" style="width:200px">
      <select id="openaiVoice" style="min-width:120px">
        <option value="alloy">Alloy</option>
        <option value="echo">Echo</option>
        <option value="fable">Fable</option>
        <option value="onyx">Onyx</option>
        <option value="nova">Nova</option>
        <option value="shimmer">Shimmer</option>
      </select>
      <button id="playOpenAI"
        style="font-weight:bold; color: #fff; background-color: #10a37f; border: none; border-radius: 4px;">Play</button>
      <button id="stop" style="background-color: #dc3545; color: white; border: none; border-radius: 4px;">Stop</button>
      <span id="openaiStatus" style="font-size: 0.9em; margin-left:10px; color:#666"></span>
    </div>
  </div>

  <pre id="content">Loading...</pre>

  <script>
    function qs(name) {
      const params = new URLSearchParams(location.search);
      return params.get(name);
    }

    const file = qs('file');
    if (!file) { document.getElementById('content').textContent = 'No file specified.'; }

    async function loadStory() {
      try {
        const decoded = decodeURIComponent(file);
        document.getElementById('title').textContent = decoded.replace(/\.txt$/i, '');
        const res = await fetch('stories/' + encodeURIComponent(decoded));
        if (!res.ok) throw new Error('Failed to fetch story: ' + res.status);
        const text = await res.text();
        document.getElementById('content').textContent = text;
      } catch (e) {
        document.getElementById('content').textContent = 'Error loading story: ' + e.message;
      }
    }

    // --- Audio Player & OpenAI Integration ---

    let audioQueue = [];
    let abortController = null;

    document.getElementById('playOpenAI').addEventListener('click', () => playOpenAI());
    document.getElementById('stop').addEventListener('click', stopAll);

    // Helper to split text into manageable chunks
    function splitText(text, maxChunkSize = 2000) {
      const regex = /[^.!?\n]+[.!?\n]+/g;
      let match;
      const chunks = [];
      let currentChunk = '';

      while ((match = regex.exec(text)) !== null) {
        if (currentChunk.length + match[0].length > maxChunkSize) {
          chunks.push(currentChunk.trim());
          currentChunk = match[0];
        } else {
          currentChunk += match[0];
        }
      }
      if (currentChunk.trim()) chunks.push(currentChunk.trim());
      if (chunks.length === 0 && text.trim()) return [text];
      return chunks;
    }

    async function playOpenAI() {
      stopAll();

      const key = document.getElementById('openaiKey').value.trim();
      const voiceId = document.getElementById('openaiVoice').value;
      const text = document.getElementById('content').textContent;
      const statusEl = document.getElementById('openaiStatus');

      if (!key) return alert('Please enter an OpenAI API Key');
      if (!text) return;

      statusEl.textContent = 'Preparing...';
      abortController = new AbortController();
      const signal = abortController.signal;

      const chunks = splitText(text);
      let chunkIndex = 0;

      async function playNextChunk() {
        if (chunkIndex >= chunks.length || signal.aborted) {
          statusEl.textContent = 'Finished.';
          return;
        }

        statusEl.textContent = `Generating chunk ${chunkIndex + 1}/${chunks.length}...`;

        try {
          const chunkText = chunks[chunkIndex];
          const resp = await fetch(`https://api.openai.com/v1/audio/speech`, {
            method: 'POST',
            headers: {
              'Authorization': `Bearer ${key}`,
              'Content-Type': 'application/json'
            },
            body: JSON.stringify({
              model: "tts-1",
              input: chunkText,
              voice: voiceId
            }),
            signal: signal
          });

          if (!resp.ok) {
            const err = await resp.text().catch(() => '');
            throw new Error(`API Error ${resp.status}: ${err}`);
          }

          const blob = await resp.blob();
          const url = URL.createObjectURL(blob);
          const audio = new Audio(url);
          audioQueue.push(audio);

          audio.onended = () => {
            URL.revokeObjectURL(url);
            const idx = audioQueue.indexOf(audio);
            if (idx > -1) audioQueue.splice(idx, 1);
            chunkIndex++;
            playNextChunk();
          };

          audio.onerror = (e) => {
            console.error('Playback error', e);
            chunkIndex++;
            playNextChunk();
          };

          statusEl.textContent = `Playing chunk ${chunkIndex + 1}...`;
          await audio.play();

        } catch (e) {
          if (e.name === 'AbortError') return;
          console.error(e);
          statusEl.textContent = 'Error: ' + e.message;
        }
      }

      playNextChunk();
    }

    function stopAll() {
      if (abortController) {
        abortController.abort();
        abortController = null;
      }
      audioQueue.forEach(a => {
        a.pause();
        a.src = '';
      });
      audioQueue = [];
      document.getElementById('openaiStatus').textContent = '';
    }

    async function initOpenAI() {
      let key = '';
      try {
        const resp = await fetch('openai.txt');
        if (resp.ok) key = (await resp.text()).trim();
      } catch (e) { console.log('No openai.txt'); }

      if (!key) {
        try {
          const resp = await fetch('/.netlify/functions/get_openai_key');
          if (resp.ok) key = (await resp.text()).trim();
        } catch (e) { }
      }

      if (key) document.getElementById('openaiKey').value = key;
    }

    let currentFontSize = 16;
    const contentEl = document.getElementById('content');

    document.getElementById('fontUp').addEventListener('click', () => {
      currentFontSize += 2;
      contentEl.style.fontSize = currentFontSize + 'px';
    });

    document.getElementById('fontDown').addEventListener('click', () => {
      currentFontSize = Math.max(8, currentFontSize - 2);
      contentEl.style.fontSize = currentFontSize + 'px';
    });

    if (file) loadStory();
    initOpenAI();
  </script>
</body>

</html>